package me.liaoheng.wallpaper.util

import android.annotation.SuppressLint
import android.content.Context
import androidx.datastore.core.CorruptionException
import androidx.datastore.core.MultiProcessDataStoreFactory
import androidx.datastore.core.Serializer
import androidx.datastore.core.handlers.ReplaceFileCorruptionHandler
import androidx.datastore.preferences.PreferencesMapCompat
import androidx.datastore.preferences.PreferencesProto.PreferenceMap
import androidx.datastore.preferences.PreferencesProto.StringSet
import androidx.datastore.preferences.PreferencesProto.Value
import androidx.datastore.preferences.core.MutablePreferences
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.core.booleanPreferencesKey
import androidx.datastore.preferences.core.byteArrayPreferencesKey
import androidx.datastore.preferences.core.doublePreferencesKey
import androidx.datastore.preferences.core.emptyPreferences
import androidx.datastore.preferences.core.floatPreferencesKey
import androidx.datastore.preferences.core.intPreferencesKey
import androidx.datastore.preferences.core.longPreferencesKey
import androidx.datastore.preferences.core.mutablePreferencesOf
import androidx.datastore.preferences.core.stringPreferencesKey
import androidx.datastore.preferences.core.stringSetPreferencesKey
import androidx.datastore.preferences.preferencesDataStoreFile
import androidx.datastore.preferences.protobuf.ByteString
import androidx.datastore.rxjava3.RxDataStore
import io.reactivex.rxjava3.core.Scheduler
import io.reactivex.rxjava3.schedulers.Schedulers
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.rx3.asCoroutineDispatcher
import java.io.File
import java.io.InputStream
import java.io.OutputStream
import java.util.concurrent.Callable

/**
 * @author liaoheng
 * @date 2025-01-23 00:01
 */
public class RxPreferenceDataStoreBuilder {

    // Either produceFile or context & name must be set, but not both.
    private var produceFile: Callable<File>? = null

    private var context: Context? = null
    private var name: String? = null

    // Optional
    private var ioScheduler: Scheduler = Schedulers.io()
    private var corruptionHandler: ReplaceFileCorruptionHandler<Preferences>? = null

    /**
     * Create a RxPreferenceDataStoreBuilder with the callable which returns the File that
     * DataStore acts on. The user is responsible for ensuring that there is never more than one
     * DataStore acting on a file at a time.
     *
     * @param produceFile Function which returns the file that the new DataStore will act on. The
     * function must return the same path every time. No two instances of DataStore should act on
     * the same file at the same time.
     */
    public constructor(produceFile: Callable<File>) {
        this.produceFile = produceFile
    }

    /**
     * Create a RxPreferenceDataStoreBuilder with the Context and name from which to derive the
     * DataStore file. The file is generated by calling
     * File(context.filesDir, "datastore/" + name + ".preferences_pb"). The user is responsible
     * for ensuring that there is never more than one DataStore acting on a file at a time.
     *
     * @param context the context from which we retrieve files directory.
     * @param name the filename relative to Context.filesDir that DataStore acts on. The File is
     * obtained by calling File(this.filesDir, "datastore/$name.preferences_pb"). No two instances
     * of DataStore should act on the same file at the same time.
     */
    public constructor(context: Context, name: String) {
        this.context = context
        this.name = name
    }

    /**
     * Set the Scheduler on which to perform IO and transform operations. This is converted into
     * a CoroutineDispatcher before being added to DataStore.
     *
     * This parameter is optional and defaults to Schedulers.io().
     *
     * @param ioScheduler the scheduler on which IO and transform operations are run
     * @return this
     */
    @Suppress("MissingGetterMatchingBuilder")
    public fun setIoScheduler(ioScheduler: Scheduler): RxPreferenceDataStoreBuilder =
        apply { this.ioScheduler = ioScheduler }

    /**
     * Sets the corruption handler to install into the DataStore.
     *
     * This parameter is optional and defaults to no corruption handler.
     *
     * @param corruptionHandler the ReplaceFileCorruptionHandler to install
     * @return this
     */
    @Suppress("MissingGetterMatchingBuilder")
    public fun setCorruptionHandler(corruptionHandler: ReplaceFileCorruptionHandler<Preferences>):
            RxPreferenceDataStoreBuilder = apply { this.corruptionHandler = corruptionHandler }

    /**
     * Build the DataStore.
     *
     * @throws IllegalStateException if serializer is not set or if neither produceFile not
     * context and name are set.
     * @return the DataStore with the provided parameters
     */
    @SuppressLint("RestrictedApi")
    public fun build(): RxDataStore<Preferences> {
        val scope = CoroutineScope(ioScheduler.asCoroutineDispatcher() + Job())

        val produceFile: Callable<File>? = this.produceFile
        val context: Context? = this.context
        val name: String? = this.name

        val delegate = if (produceFile != null) {
            MultiProcessDataStoreFactory.create(
                PreferencesSerializer,
                produceFile = { produceFile.call() },
                scope = scope,
                corruptionHandler = corruptionHandler,
            )
        } else if (context != null && name != null) {
            MultiProcessDataStoreFactory.create(
                PreferencesSerializer,
                produceFile = { context.preferencesDataStoreFile(name) },
                scope = scope,
                corruptionHandler = corruptionHandler,
            )
        } else {
            error("Either produceFile or context and name must be set. This should never happen.")
        }

        return RxDataStore.create(delegate, scope)
    }

    object PreferencesSerializer : Serializer<Preferences> {
        override val defaultValue: Preferences
            get() = emptyPreferences()

        @SuppressLint("RestrictedApi")
        override suspend fun readFrom(input: InputStream): Preferences {
            val preferencesProto = PreferencesMapCompat.readFrom(input)

            val mutablePreferences = mutablePreferencesOf()

            preferencesProto.preferencesMap.forEach { (name, value) ->
                addProtoEntryToPreferences(name, value, mutablePreferences)
            }

            return mutablePreferences.toPreferences()
        }

        override suspend fun writeTo(t: Preferences, output: OutputStream) {
            val preferences = t.asMap()
            val protoBuilder = PreferenceMap.newBuilder()

            for ((key, value) in preferences) {
                protoBuilder.putPreferences(
                    key.name,
                    getValueProto(value)
                )
            }

            protoBuilder.build().writeTo(output)
        }


        private fun getValueProto(value: Any): Value {
            return when (value) {
                is Boolean -> Value.newBuilder().setBoolean(value).build()
                is Float -> Value.newBuilder().setFloat(value).build()
                is Double -> Value.newBuilder().setDouble(value).build()
                is Int -> Value.newBuilder().setInteger(value).build()
                is Long -> Value.newBuilder().setLong(value).build()
                is String -> Value.newBuilder().setString(value).build()
                is Set<*> ->
                    @Suppress("UNCHECKED_CAST")
                    Value.newBuilder().setStringSet(
                        StringSet.newBuilder().addAllStrings(value as Set<String>)
                    ).build()

                is ByteArray -> Value.newBuilder().setBytes(ByteString.copyFrom(value)).build()
                else -> throw IllegalStateException(
                    "PreferencesSerializer does not support type: ${value.javaClass.name}"
                )
            }
        }

        private fun addProtoEntryToPreferences(
            name: String,
            value: Value,
            mutablePreferences: MutablePreferences
        ) {
            return when (value.valueCase) {
                Value.ValueCase.BOOLEAN ->
                    mutablePreferences[booleanPreferencesKey(name)] =
                        value.boolean

                Value.ValueCase.FLOAT -> mutablePreferences[floatPreferencesKey(name)] = value.float
                Value.ValueCase.DOUBLE -> mutablePreferences[doublePreferencesKey(name)] =
                    value.double

                Value.ValueCase.INTEGER -> mutablePreferences[intPreferencesKey(name)] =
                    value.integer

                Value.ValueCase.LONG -> mutablePreferences[longPreferencesKey(name)] = value.long
                Value.ValueCase.STRING -> mutablePreferences[stringPreferencesKey(name)] =
                    value.string

                Value.ValueCase.STRING_SET ->
                    mutablePreferences[stringSetPreferencesKey(name)] =
                        value.stringSet.stringsList.toSet()

                Value.ValueCase.BYTES ->
                    mutablePreferences[byteArrayPreferencesKey(name)] = value.bytes.toByteArray()

                Value.ValueCase.VALUE_NOT_SET ->
                    throw CorruptionException("Value not set.")

                null -> throw CorruptionException("Value case is null.")
            }
        }
    }


}